<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaucho Guardian</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            line-height: 1.6;
            color: #1f2937;
            background: linear-gradient(to bottom, #f9fafb 0%, #ffffff 100%);
            padding: 2rem;
            max-width: 1600px;
            margin: 0 auto;
            min-height: 100vh;
        }

        .header {
            margin-bottom: 2.5rem;
        }

        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: #111827;
            letter-spacing: -0.02em;
        }

        .subtitle {
            color: #6b7280;
            font-size: 1rem;
        }

        .main-container {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        /* Ensure uniform spacing between sections regardless of collapsed state */
        .sidebar > * {
            margin: 0;
        }

        .search-section,
        .selected-courses,
        .schedule-optimizer {
            background: #ffffff;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            transition: padding 0.15s ease;
        }

        .search-section.collapsed,
        .selected-courses.collapsed,
        .schedule-optimizer.collapsed {
            padding: 0.75rem 1.5rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            cursor: pointer;
            user-select: none;
            transition: margin-bottom 0.15s ease;
            min-height: 28px;
        }

        .search-section.collapsed .section-header,
        .selected-courses.collapsed .section-header,
        .schedule-optimizer.collapsed .section-header {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
            color: #111827;
            letter-spacing: -0.01em;
            flex: 1;
        }

        .collapse-toggle {
            background: none;
            border: none;
            color: #6b7280;
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: transform 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            flex-shrink: 0;
            transform-origin: center center;
            position: relative;
        }

        .collapse-toggle:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .collapse-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .section-header:active .collapse-toggle {
            transform: scale(0.95);
        }

        .section-header:active .collapse-toggle.collapsed {
            transform: rotate(-90deg) scale(0.95);
        }

        .section-content {
            overflow: hidden;
            transition: max-height 0.15s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.1s ease,
                        margin 0.15s ease,
                        padding 0.15s ease;
            max-height: 5000px;
            opacity: 1;
        }

        .section-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            margin-top: 0;
            margin-bottom: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        .search-section .section-content.collapsed,
        .selected-courses .section-content.collapsed,
        .schedule-optimizer .section-content.collapsed {
            margin: 0;
        }

        /* Add collapsed class to parent section when content is collapsed */
        .search-section:has(.section-content.collapsed),
        .selected-courses:has(.section-content.collapsed),
        .schedule-optimizer:has(.section-content.collapsed) {
            padding: 0.75rem 1.5rem;
        }

        input[type="text"],
        select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1.5px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: inherit;
            background: #ffffff;
            transition: all 0.2s ease;
        }

        input[type="text"] {
            margin-bottom: 0.75rem;
        }

        select {
            margin-bottom: 0.75rem;
        }

        input[type="text"]:focus,
        select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 0.625rem;
            margin-top: 0.25rem;
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: 8px;
        }

        .filter-checkbox:first-of-type {
            margin-top: 0.75rem;
        }

        .filter-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #3b82f6;
        }

        .filter-checkbox label {
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
        }

        .general-subject-filter {
            margin-bottom: 0.75rem;
        }

        .general-subject-checkboxes {
            max-height: 200px;
            overflow-y: auto;
            border: 1.5px solid #e5e7eb;
            border-radius: 8px;
            padding: 0.5rem;
            background: #ffffff;
        }

        .general-subject-checkboxes::-webkit-scrollbar {
            width: 6px;
        }

        .general-subject-checkboxes::-webkit-scrollbar-track {
            background: #f9fafb;
            border-radius: 4px;
        }

        .general-subject-checkboxes::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }

        .general-subject-checkboxes::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        .general-subject-checkboxes .filter-checkbox {
            margin-top: 0.25rem;
            margin-bottom: 0.25rem;
        }

        .general-subject-checkboxes .filter-checkbox:first-of-type {
            margin-top: 0;
        }

        #filterStatus {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 0.5rem;
            min-height: 1.2rem;
            padding-left: 0.25rem;
        }

        .search-results {
            border: 1.5px solid #e5e7eb;
            border-radius: 8px;
            max-height: 420px;
            overflow-y: auto;
            background: #ffffff;
            margin-top: 1rem;
        }

        .search-results::-webkit-scrollbar {
            width: 8px;
        }

        .search-results::-webkit-scrollbar-track {
            background: #f9fafb;
            border-radius: 8px;
        }

        .search-results::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 4px;
        }

        .search-results::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        .course-item {
            padding: 1rem;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .course-item:hover {
            background-color: #f9fafb;
        }

        .course-item:last-child {
            border-bottom: none;
        }

        .course-code {
            font-weight: 600;
            font-size: 0.9rem;
            color: #2563eb;
            margin-bottom: 0.375rem;
        }

        .course-title {
            font-size: 0.875rem;
            color: #374151;
            margin-bottom: 0.25rem;
            line-height: 1.4;
        }

        .course-meta {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .selected-course {
            padding: 1rem;
            background: #f9fafb;
            border-radius: 8px;
            border: 1.5px solid #e5e7eb;
            margin-bottom: 0.75rem;
            transition: all 0.2s ease;
        }

        .selected-course:hover {
            border-color: #d1d5db;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .selected-course-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
        }

        .remove-btn {
            background: none;
            border: none;
            color: #dc2626;
            cursor: pointer;
            font-size: 0.875rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .remove-btn:hover {
            background: #fee2e2;
            color: #b91c1c;
        }

        .calendar-container {
            background: #ffffff;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            transition: box-shadow 0.3s ease;
            position: sticky;
            top: 2rem;
            align-self: flex-start;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .calendar-container.updating {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2), 0 4px 12px rgba(59, 130, 246, 0.15);
        }

        .calendar-container::-webkit-scrollbar {
            width: 8px;
        }

        .calendar-container::-webkit-scrollbar-track {
            background: #f9fafb;
            border-radius: 8px;
        }

        .calendar-container::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 4px;
        }

        .calendar-container::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        .calendar-header {
            margin-bottom: 1rem;
        }

        .calendar-header h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #111827;
            letter-spacing: -0.01em;
        }

        .calendar-wrapper {
            display: grid;
            grid-template-columns: 80px repeat(5, 1fr);
            gap: 1px;
            background: #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e5e7eb;
        }

        .time-column {
            background: #f9fafb;
            display: flex;
            flex-direction: column;
        }

        .time-column-header {
            background: #f3f4f6;
            height: 40px;
            border-bottom: 2px solid #d1d5db;
        }

        .time-slot {
            background: #ffffff;
            padding: 0 0.5rem;
            font-size: 0.75rem;
            color: #6b7280;
            text-align: right;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            border-bottom: 1px solid #f3f4f6;
        }

        .time-slot.hour-mark {
            font-weight: 600;
            color: #374151;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }

        .day-column {
            background: #ffffff;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .day-header {
            background: #f3f4f6;
            padding: 0.75rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.875rem;
            color: #374151;
            position: sticky;
            top: 0;
            z-index: 10;
            border-bottom: 2px solid #d1d5db;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .day-content {
            position: relative;
            flex: 1;
            min-height: 840px;
            background-image: 
                repeating-linear-gradient(
                    to bottom,
                    transparent 0,
                    transparent 29px,
                    #f3f4f6 29px,
                    #f3f4f6 30px
                ),
                repeating-linear-gradient(
                    to bottom,
                    transparent 0,
                    transparent 59px,
                    #e5e7eb 59px,
                    #e5e7eb 60px
                );
        }

        .course-block {
            position: absolute;
            left: 2px;
            right: 2px;
            padding: 0.5rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #ffffff;
            font-weight: 500;
            cursor: pointer;
            overflow: hidden;
            z-index: 5;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            line-height: 1.3;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            animation: slide-in 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slide-in {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes slide-in-preview {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.95);
            }
            to {
                opacity: 0.7;
                transform: translateY(0) scale(1);
            }
        }
        
        .course-block > div {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .course-block:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 6;
        }

        .course-block.updating {
            animation: highlight-update 0.6s ease-out;
        }

        .course-block.preview-block {
            opacity: 0.7;
            border: 2px dashed rgba(255, 255, 255, 0.6);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2), inset 0 0 0 1px rgba(255, 255, 255, 0.3);
            animation: slide-in-preview 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes highlight-update {
            0%, 100% {
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            }
            50% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.4), 0 4px 12px rgba(59, 130, 246, 0.3);
            }
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1.5rem;
            color: #9ca3af;
            font-size: 0.9rem;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #6b7280;
            font-size: 0.9rem;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #ffffff;
            border-radius: 12px;
            padding: 2rem;
            max-width: 650px;
            max-height: 85vh;
            overflow-y: auto;
            width: 90%;
            position: relative;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        .modal-content::-webkit-scrollbar {
            width: 8px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: #f9fafb;
            border-radius: 8px;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 4px;
        }

        .modal-header {
            margin-bottom: 1.5rem;
            padding-right: 2rem;
        }

        .modal-header h3 {
            font-size: 1.375rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #111827;
            letter-spacing: -0.01em;
        }

        .modal-header p {
            color: #6b7280;
            font-size: 0.9rem;
        }

        .close-btn {
            position: absolute;
            top: 1.25rem;
            right: 1.25rem;
            background: #f3f4f6;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            line-height: 1;
        }

        .close-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .section-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .section-item {
            padding: 1rem;
            border: 1.5px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #ffffff;
        }

        .section-item:hover {
            background-color: #f9fafb;
            border-color: #d1d5db;
        }

        .section-item.selected {
            background-color: #eff6ff;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .lecture-time {
            font-weight: 600;
            margin-bottom: 0.375rem;
            color: #111827;
            font-size: 0.9rem;
        }

        .lecture-meta {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        .add-btn {
            margin-top: 1.5rem;
            padding: 0.875rem 1.5rem;
            background: #3b82f6;
            color: #ffffff;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .add-btn:hover {
            background: #2563eb;
            box-shadow: 0 4px 6px rgba(59, 130, 246, 0.2);
        }

        .add-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
            box-shadow: none;
        }

        .conflict-badge {
            font-size: 0.75rem;
            margin-left: 0.5rem;
            font-weight: 500;
        }

        .conflict-free {
            color: #059669;
        }

        .conflict-warning {
            color: #dc2626;
        }

        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        .day-abbr {
            display: none;
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            .day-label {
                display: none;
            }
            .day-abbr {
                display: block;
            }
            .search-section,
            .selected-courses {
                padding: 1rem;
            }
        }

        /* Schedule Optimizer Styles */

        .optimizer-controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .preference-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .preference-group label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
        }

        .radio-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .radio-option input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #3b82f6;
        }

        .radio-option label {
            font-size: 0.875rem;
            color: #374151;
            cursor: pointer;
            font-weight: normal;
        }

        .time-inputs {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .time-inputs select {
            flex: 1;
            padding: 0.5rem;
            border: 1.5px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.875rem;
            font-family: inherit;
            background: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .time-inputs select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .checkbox-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .checkbox-inline {
            margin: 0;
            flex: 1;
            min-width: 160px;
        }

        .max-classes-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .max-classes-label {
            font-size: 0.875rem;
            color: #6b7280;
            margin: 0;
            line-height: 1.5;
            white-space: nowrap;
        }

        .max-classes-select {
            max-width: 120px;
            padding: 0.5rem;
            border: 1.5px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.875rem;
            font-family: inherit;
            background: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .max-classes-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .optimizer-status {
            font-size: 0.875rem;
            color: #6b7280;
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-radius: 6px;
            background: #f9fafb;
            transition: all 0.2s ease;
        }

        .optimizer-status.loading {
            color: #3b82f6;
            background: #eff6ff;
        }

        .optimizer-status.error {
            color: #dc2626;
            background: #fee2e2;
        }

        .optimizer-status.success {
            color: #059669;
            background: #d1fae5;
        }

        .optimized-schedules {
            margin-top: 1.5rem;
        }

        .schedule-option {
            background: #f9fafb;
            border: 1.5px solid #e5e7eb;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .schedule-option:hover {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
            transform: translateY(-2px);
        }

        .schedule-option.selected:not(.applied) {
            background-color: #eff6ff;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .schedule-option.applied {
            background-color: #f0fdf4;
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
        }

        .schedule-option.selected {
            background-color: #eff6ff;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2), 0 4px 12px rgba(59, 130, 246, 0.15);
            transform: translateY(-2px);
        }

        .schedule-option.applying {
            animation: pulse-apply 0.6s ease-out;
        }

        @keyframes pulse-apply {
            0% {
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2), 0 4px 12px rgba(59, 130, 246, 0.15);
            }
            50% {
                box-shadow: 0 0 0 6px rgba(59, 130, 246, 0.3), 0 8px 20px rgba(59, 130, 246, 0.25);
            }
            100% {
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2), 0 4px 12px rgba(59, 130, 246, 0.15);
            }
        }

        .schedule-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .schedule-score {
            font-weight: 600;
            color: #059669;
            font-size: 0.9rem;
        }

        .schedule-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #e5e7eb;
        }

        .schedule-actions button {
            flex: 1;
        }

        .apply-schedule-btn {
            flex: 1;
            padding: 0.625rem 1rem;
            background: #3b82f6;
            color: #ffffff;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .apply-schedule-btn:hover {
            background: #2563eb;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
        }

        .apply-schedule-btn.applied {
            background: #10b981;
        }

        .apply-schedule-btn.applied:hover {
            background: #059669;
        }

        .remove-schedule-btn {
            flex: 1;
            padding: 0.625rem 1rem;
            background: #f3f4f6;
            color: #374151;
            border: 1.5px solid #e5e7eb;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .remove-schedule-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }

        .schedule-actions button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .applied-badge {
            display: inline-block;
            background: #10b981;
            color: #ffffff;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            animation: fade-in 0.3s ease-out;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .schedule-courses-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .schedule-course-item {
            font-size: 0.875rem;
            color: #374151;
            padding: 0.5rem;
            background: #ffffff;
            border-radius: 4px;
        }

        .loading-optimization {
            text-align: center;
            padding: 2rem;
            color: #6b7280;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <div class="search-section">
                <div class="section-header" onclick="toggleSection('searchSection')">
                    <h3 class="section-title">Search Courses</h3>
                    <button class="collapse-toggle" id="searchSectionToggle" aria-label="Toggle search section" onclick="event.stopPropagation(); toggleSection('searchSection');">â–¼</button>
                </div>
                <div class="section-content" id="searchSection">
                    <input type="text" id="searchInput" placeholder="Search by course ID, title, or department...">
                    <select id="departmentSelect">
                        <option value="">All Departments</option>
                    </select>
                    <div class="general-subject-filter">
                        <label style="font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem; display: block;">General Subject Requirements (select multiple):</label>
                        <div class="general-subject-checkboxes">
                            <div class="filter-checkbox">
                                <input type="checkbox" id="generalSubjectA" value="A" class="general-subject-checkbox">
                                <label for="generalSubjectA">Area A: English Reading and Composition</label>
                            </div>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="generalSubjectB" value="B" class="general-subject-checkbox">
                                <label for="generalSubjectB">Area B: Foreign Language</label>
                            </div>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="generalSubjectC" value="C" class="general-subject-checkbox">
                                <label for="generalSubjectC">Area C: Science, Mathematics, and Technology</label>
                            </div>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="generalSubjectD" value="D" class="general-subject-checkbox">
                                <label for="generalSubjectD">Area D: Social Sciences</label>
                            </div>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="generalSubjectE" value="E" class="general-subject-checkbox">
                                <label for="generalSubjectE">Area E: Culture and Thought</label>
                            </div>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="generalSubjectF" value="F" class="general-subject-checkbox">
                                <label for="generalSubjectF">Area F: Arts</label>
                            </div>
                            <div class="filter-checkbox">
                                <input type="checkbox" id="generalSubjectG" value="G" class="general-subject-checkbox">
                                <label for="generalSubjectG">Area G: Literature</label>
                            </div>
                        </div>
                    </div>
                    <select id="specialSubjectSelect">
                        <option value="">All Special Subject Requirements</option>
                        <option value="ETH">Ethnicity</option>
                        <option value="EUR">European Traditions</option>
                        <option value="NWC">Non-Western Cultures</option>
                        <option value="QNT">Quantitative Relationships</option>
                        <option value="WRT">Writing</option>
                    </select>
                    <div class="filter-checkbox">
                        <input type="checkbox" id="filterBySchedule" checked>
                        <label for="filterBySchedule">Show only classes with no time conflicts</label>
                    </div>
                    <div id="filterStatus"></div>
                    <div class="search-results" id="searchResults">
                        <div class="empty-state">Loading courses...</div>
                    </div>
                </div>
            </div>

            <div class="selected-courses">
                <div class="section-header" onclick="toggleSection('selectedCoursesSection')">
                    <h3 class="section-title">Selected Courses <span id="totalUnitsDisplay" style="font-size: 0.85rem; font-weight: normal; color: #6b7280; margin-left: 0.5rem;"></span></h3>
                    <button class="collapse-toggle" id="selectedCoursesSectionToggle" aria-label="Toggle selected courses section">â–¼</button>
                </div>
                <div class="section-content" id="selectedCoursesSection">
                    <div id="selectedCoursesList">
                        <div class="empty-state" style="padding: 1.5rem 1rem;">No courses selected</div>
                    </div>
                </div>
            </div>

            <div class="schedule-optimizer">
                <div class="section-header" onclick="toggleSection('optimizerSection')">
                    <h3 class="section-title">Schedule Optimizer</h3>
                    <button class="collapse-toggle" id="optimizerSectionToggle" aria-label="Toggle optimizer section" onclick="event.stopPropagation(); toggleSection('optimizerSection');">â–¼</button>
                </div>
                <div class="section-content" id="optimizerSection">
                    <div class="optimizer-controls">
                        <div class="preference-group">
                            <label>Schedule Layout</label>
                            <div class="radio-group">
                                <div class="radio-option">
                                    <input type="radio" id="spreadCentered" name="spreadPreference" value="centered" checked>
                                    <label for="spreadCentered">Centered</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" id="spreadSpread" name="spreadPreference" value="spread">
                                    <label for="spreadSpread">Spread Out</label>
                                </div>
                            </div>
                        </div>

                        <div class="preference-group">
                            <label>Time Preferences</label>
                            <div class="time-inputs">
                                <select id="preferredStartTime">
                                </select>
                                <span>to</span>
                                <select id="preferredEndTime">
                                </select>
                            </div>
                            <div class="radio-group">
                                <div class="radio-option">
                                    <input type="radio" id="timeMorning" name="preferredTimeOfDay" value="morning">
                                    <label for="timeMorning">Morning</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" id="timeAfternoon" name="preferredTimeOfDay" value="afternoon">
                                    <label for="timeAfternoon">Afternoon</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" id="timeEvening" name="preferredTimeOfDay" value="evening">
                                    <label for="timeEvening">Evening</label>
                                </div>
                                <div class="radio-option">
                                    <input type="radio" id="timeNone" name="preferredTimeOfDay" value="" checked>
                                    <label for="timeNone">Any time</label>
                                </div>
                            </div>
                        </div>

                        <div class="preference-group">
                            <label>Schedule Structure</label>
                            <div class="checkbox-row">
                                <div class="filter-checkbox checkbox-inline">
                                    <input type="checkbox" id="prioritizeFreeDays">
                                    <label for="prioritizeFreeDays">More free days</label>
                                </div>
                                <div class="filter-checkbox checkbox-inline">
                                    <input type="checkbox" id="minimizeGaps">
                                    <label for="minimizeGaps">Minimize gaps</label>
                                </div>
                            </div>
                            <div class="max-classes-row">
                                <label class="max-classes-label">Max per day:</label>
                                <select id="maxClassesPerDay" class="max-classes-select">
                                    <option value="">No limit</option>
                                    <option value="2">2</option>
                                    <option value="3">3</option>
                                    <option value="4">4</option>
                                    <option value="5">5</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div id="optimizedSchedules" class="optimized-schedules" style="display: none;">
                        <h4 class="section-title" style="margin-top: 1.5rem; margin-bottom: 1rem;">Optimized Schedules</h4>
                        <div id="scheduleOptions"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="calendar-container">
            <div class="calendar-header">
                <h2>Weekly Schedule</h2>
                <div id="previewIndicator" style="display: none; font-size: 0.875rem; color: #3b82f6; font-weight: 500; margin-top: 0.5rem;">
                    âš  Preview Mode - Apply to save changes
                </div>
            </div>
            <div class="calendar-wrapper" id="calendarWrapper"></div>
        </div>
    </div>

    <!-- Modal for section selection -->
    <div class="modal" id="selectionModal">
        <div class="modal-content">
            <button class="close-btn" onclick="closeModal()">&times;</button>
            <div id="modalContent"></div>
        </div>
    </div>

    <script>
        // State
        let selectedCourses = [];
        let searchTimeout = null;
        let currentCourse = null;
        let currentLecture = null;
        let selectedLectureIndex = null; // Single selected lecture index (only one allowed)
        let selectedSectionIndex = null;
        let conflictFreeCombinations = [];
        let courseConflictData = {}; // Map courseId -> conflictFreeCombinations

        // Helper function to update selectedCourses and ALWAYS save (unless explicitly skipped)
        function updateSelectedCourses(newCourses, skipSave = false) {
            selectedCourses = newCourses;
            if (!skipSave) {
                saveSelectedCoursesToCookie();
            }
        }

        // Storage helper functions - using localStorage (much larger limit than cookies)
        function setCookie(name, value, days = 365) {
            // Legacy function name - now uses localStorage
            try {
                localStorage.setItem(name, value);
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    console.error('âŒ Storage quota exceeded! Cannot save courses.');
                    alert('Storage limit reached! Please remove some courses and try again.');
                } else {
                    console.error('âŒ Error saving to localStorage:', error);
                }
            }
        }

        function getCookie(name) {
            // Legacy function name - now uses localStorage
            return localStorage.getItem(name);
        }

        // Save selected courses to storage (localStorage)
        function saveSelectedCoursesToCookie() {
            try {
                const coursesJson = JSON.stringify(selectedCourses);
                const sizeKB = (new Blob([coursesJson]).size / 1024).toFixed(2);
                console.log('ðŸ’¾ Saving to localStorage:', selectedCourses.length, 'courses', `(${sizeKB} KB)`);
                
                localStorage.setItem('selectedCourses', coursesJson);
                
                // Verify it was saved
                const verify = localStorage.getItem('selectedCourses');
                if (verify) {
                    const verifiedCourses = JSON.parse(verify);
                    console.log('âœ… Saved successfully! Verified:', verifiedCourses.length, 'courses');
                } else {
                    console.error('âŒ Save failed - verification returned null');
                }
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    console.error('âŒ Storage quota exceeded! Cannot save courses.');
                    alert('Storage limit reached! Please remove some courses and try again.');
                } else {
                    console.error('âŒ Error saving courses:', error);
                }
            }
        }

        // Load selected courses from storage (localStorage, with cookie fallback for migration)
        function loadSelectedCoursesFromCookie() {
            try {
                // Try localStorage first
                let coursesJson = localStorage.getItem('selectedCourses');
                
                // If not in localStorage, try migrating from cookie (one-time migration)
                if (!coursesJson) {
                    const cookieValue = document.cookie.split(';').find(c => c.trim().startsWith('selectedCourses='));
                    if (cookieValue) {
                        const cookieJson = decodeURIComponent(cookieValue.split('=')[1]);
                        console.log('ðŸ”„ Migrating courses from cookie to localStorage...');
                        coursesJson = cookieJson;
                        // Save to localStorage for future use
                        if (coursesJson) {
                            localStorage.setItem('selectedCourses', coursesJson);
                        }
                    }
                }
                
                console.log('ðŸ” Loading courses from storage...', coursesJson ? 'Data found' : 'No data found');
                
                if (coursesJson) {
                    const loadedCourses = JSON.parse(coursesJson);
                    console.log('ðŸ“¦ Parsed courses:', loadedCourses.length, 'courses');
                    
                    if (Array.isArray(loadedCourses) && loadedCourses.length > 0) {
                        console.log('âœ… Loading', loadedCourses.length, 'courses into selectedCourses');
                        // Set both selectedCourses and masterSelectedCourses
                        updateSelectedCourses(loadedCourses, true); // Skip save on load
                        masterSelectedCourses = JSON.parse(JSON.stringify(loadedCourses)); // Initialize master schedule
                        console.log('âœ… Courses loaded. selectedCourses:', selectedCourses.length, 'masterSelectedCourses:', masterSelectedCourses.length);
                        console.log('ðŸ“‹ First course sample:', selectedCourses[0]?.courseId || 'none');
                        return true;
                    } else {
                        console.log('âš ï¸ Loaded courses is not a valid array or is empty');
                    }
                } else {
                    console.log('âš ï¸ No courses found in storage');
                }
            } catch (error) {
                console.error('âŒ Error loading courses:', error);
            }
            return false;
        }

        // Section collapse/expand functionality
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId);
            const toggle = document.getElementById(sectionId + 'Toggle');
            
            if (!content || !toggle) {
                return;
            }
            
            // Find parent section element
            const parentSection = content.closest('.search-section, .selected-courses, .schedule-optimizer');
            
            const isCollapsed = content.classList.contains('collapsed');
            
            if (isCollapsed) {
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                if (parentSection) {
                    parentSection.classList.remove('collapsed');
                }
            } else {
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
                if (parentSection) {
                    parentSection.classList.add('collapsed');
                }
            }
            
            // Save state to localStorage
            try {
                const state = JSON.parse(localStorage.getItem('sectionStates') || '{}');
                state[sectionId] = !isCollapsed;
                localStorage.setItem('sectionStates', JSON.stringify(state));
            } catch (e) {
                console.error('Error saving section state:', e);
            }
        }

        // Load saved section states
        function loadSectionStates() {
            try {
                const state = JSON.parse(localStorage.getItem('sectionStates') || '{}');
                Object.keys(state).forEach(sectionId => {
                    if (state[sectionId]) {
                        const content = document.getElementById(sectionId);
                        const toggle = document.getElementById(sectionId + 'Toggle');
                        if (content && toggle) {
                            content.classList.add('collapsed');
                            toggle.classList.add('collapsed');
                            // Also add collapsed class to parent section
                            const parentSection = content.closest('.search-section, .selected-courses, .schedule-optimizer');
                            if (parentSection) {
                                parentSection.classList.add('collapsed');
                            }
                        }
                    }
                });
            } catch (e) {
                console.error('Error loading section states:', e);
            }
        }

        // Initialize
        async function init() {
            await loadDepartments();
            initCalendar();
            initTimeDropdowns();
            
            // Load saved courses from cookie (this also initializes masterSelectedCourses)
            const coursesLoaded = loadSelectedCoursesFromCookie();
            
            // Automatically check the filter by schedule checkbox
            document.getElementById('filterBySchedule').checked = true;
            
            // Load saved section states
            setTimeout(loadSectionStates, 100);
            
            document.getElementById('searchInput').addEventListener('input', handleSearch);
            document.getElementById('departmentSelect').addEventListener('change', handleSearch);
            document.getElementById('specialSubjectSelect').addEventListener('change', handleSearch);
            // Add event listeners for all general subject checkboxes
            document.querySelectorAll('.general-subject-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', handleSearch);
            });
            document.getElementById('filterBySchedule').addEventListener('change', handleSearch);
            
            // Add event listeners for automatic optimization
            document.querySelectorAll('input[name="spreadPreference"]').forEach(radio => {
                radio.addEventListener('change', autoOptimize);
            });
            document.getElementById('preferredStartTime').addEventListener('change', () => {
                updateEndTimeDropdown();
                autoOptimize();
            });
            document.getElementById('preferredEndTime').addEventListener('change', autoOptimize);
            document.getElementById('prioritizeFreeDays').addEventListener('change', autoOptimize);
            document.getElementById('minimizeGaps').addEventListener('change', autoOptimize);
            document.getElementById('maxClassesPerDay').addEventListener('change', autoOptimize);
            document.querySelectorAll('input[name="preferredTimeOfDay"]').forEach(radio => {
                radio.addEventListener('change', autoOptimize);
            });
            
            // Helper to trigger re-search if filter is active
            function triggerSearchIfFiltered() {
                if (document.getElementById('filterBySchedule').checked) {
                    handleSearch();
                }
            }
            
            // Store original functions
            window.triggerSearchIfFiltered = triggerSearchIfFiltered;
            
            // If courses were loaded, update the UI after a brief delay to ensure calendar is ready
            if (coursesLoaded && selectedCourses.length > 0) {
                console.log('ðŸ”„ Updating UI with loaded courses:', selectedCourses.length);
                setTimeout(() => {
                    updateSelectedCoursesList();
                    updateCalendar();
                    console.log('âœ… UI updated with', selectedCourses.length, 'courses');
                }, 100);
            } else {
                console.log('âš ï¸ No courses loaded or courses array is empty');
                // Update total units display even if no courses (to clear it)
                setTimeout(() => {
                    updateTotalUnitsDisplay();
                }, 100);
            }
            
            // Automatically load all courses on page load
            handleSearch();
            
            // Auto-optimize on initial load if courses are already selected
            if (coursesLoaded && selectedCourses.length > 0) {
                setTimeout(autoOptimize, 1000); // Small delay to ensure everything is loaded
            }
        }

        async function loadDepartments() {
            try {
                const response = await fetch('/api/departments');
                const departments = await response.json();
                const select = document.getElementById('departmentSelect');
                departments.forEach(dept => {
                    const option = document.createElement('option');
                    option.value = dept;
                    option.textContent = dept;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading departments:', error);
            }
        }

        function formatTime12HourWithMinutes(timeStr) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            const period = hours >= 12 ? 'PM' : 'AM';
            const displayHour = hours === 0 ? 12 : (hours > 12 ? hours - 12 : hours);
            return `${displayHour}:${minutes.toString().padStart(2, '0')} ${period}`;
        }

        function updateEndTimeDropdown() {
            const startSelect = document.getElementById('preferredStartTime');
            const endSelect = document.getElementById('preferredEndTime');
            const selectedStartTime = startSelect.value;
            
            // Clear existing options
            endSelect.innerHTML = '';
            
            if (!selectedStartTime) {
                // If no start time selected, show all options
                for (let hour = 8; hour <= 22; hour++) {
                    const time24 = `${hour.toString().padStart(2, '0')}:00`;
                    const time12 = formatTime12HourWithMinutes(time24);
                    const endOption = document.createElement('option');
                    endOption.value = time24;
                    endOption.textContent = time12;
                    if (hour === 15) {
                        endOption.selected = true;
                    }
                    endSelect.appendChild(endOption);
                }
                return;
            }
            
            // Parse start time to get the hour
            const [startHour] = selectedStartTime.split(':').map(Number);
            
            // Only show times after the start time
            for (let hour = startHour + 1; hour <= 22; hour++) {
                const time24 = `${hour.toString().padStart(2, '0')}:00`;
                const time12 = formatTime12HourWithMinutes(time24);
                const endOption = document.createElement('option');
                endOption.value = time24;
                endOption.textContent = time12;
                // Select first available option or default to 15:00 if it's still valid
                if (hour === Math.max(startHour + 1, 15) && hour <= 15) {
                    endOption.selected = true;
                }
                endSelect.appendChild(endOption);
            }
            
            // If no options were added (start time is 10 PM or later), select the first option (which will be empty)
            if (endSelect.options.length === 0) {
                // This shouldn't happen since we always have at least one option, but handle it gracefully
                endSelect.value = '';
            }
        }

        function initTimeDropdowns() {
            const startSelect = document.getElementById('preferredStartTime');
            const endSelect = document.getElementById('preferredEndTime');
            
            // Generate hourly options from 8 AM to 10 PM for start time
            for (let hour = 8; hour <= 22; hour++) {
                const time24 = `${hour.toString().padStart(2, '0')}:00`;
                const time12 = formatTime12HourWithMinutes(time24);
                
                const startOption = document.createElement('option');
                startOption.value = time24;
                startOption.textContent = time12;
                if (hour === 10) {
                    startOption.selected = true; // Default to 10:00 AM
                }
                startSelect.appendChild(startOption);
            }
            
            // Initialize end time dropdown
            updateEndTimeDropdown();
            
            // Add event listener to update end time when start time changes
            startSelect.addEventListener('change', updateEndTimeDropdown);
        }

        async function handleSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(async () => {
                const query = document.getElementById('searchInput').value.trim();
                const department = document.getElementById('departmentSelect').value;
                const specialSubject = document.getElementById('specialSubjectSelect').value;
                // Collect all checked general subject checkboxes into an array
                const generalSubjects = Array.from(document.querySelectorAll('.general-subject-checkbox:checked'))
                    .map(checkbox => checkbox.value);
                const filterBySchedule = document.getElementById('filterBySchedule').checked;
                
                document.getElementById('searchResults').innerHTML = 
                    '<div class="loading">Searching...</div>';
                
                try {
                    const response = await fetch('/api/search', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            q: query,
                            dept: department,
                            generalSubjects: generalSubjects, // Send as array
                            specialSubject: specialSubject, // Send as single value
                            selectedCourses: filterBySchedule ? selectedCourses : []
                        })
                    });
                    const data = await response.json();
                    
                    if (data.success) {
                        displaySearchResults(data.courses);
                    } else {
                        document.getElementById('searchResults').innerHTML = 
                            '<div class="empty-state">Error searching courses</div>';
                    }
                } catch (error) {
                    console.error('Search error:', error);
                    document.getElementById('searchResults').innerHTML = 
                        '<div class="empty-state">Error searching courses</div>';
                }
            }, 300);
        }

        function displaySearchResults(courses) {
            const container = document.getElementById('searchResults');
            const filterStatus = document.getElementById('filterStatus');
            const filterBySchedule = document.getElementById('filterBySchedule').checked;
            
            // Update filter status
            if (filterBySchedule && selectedCourses.length > 0) {
                filterStatus.textContent = `Showing ${courses.length} course(s) with no time conflicts`;
                filterStatus.style.color = '#0066cc';
            } else if (filterBySchedule && selectedCourses.length === 0) {
                filterStatus.textContent = 'Add courses to your schedule to filter by conflicts';
                filterStatus.style.color = '#999';
            } else {
                filterStatus.textContent = '';
            }
            
            if (courses.length === 0) {
                if (filterBySchedule && selectedCourses.length > 0) {
                    container.innerHTML = '<div class="empty-state">No courses found without time conflicts. Try unchecking the filter or adjusting your schedule.</div>';
                } else {
                    container.innerHTML = '<div class="empty-state">No courses found</div>';
                }
                return;
            }
            
            // Store conflict-free combinations for each course
            courses.forEach(course => {
                if (course._conflictFreeCombinations) {
                    courseConflictData[course.courseId] = course._conflictFreeCombinations;
                }
            });
            
            container.innerHTML = courses.map(course => {
                // courseId already includes subject area (e.g., "CMPSC 16"), so just use it directly
                const displayCode = course.courseId;
                return `
                <div class="course-item" onclick="openCourse('${course.courseId.replace(/'/g, "\\'")}')">
                    <div class="course-code">${displayCode}</div>
                    <div class="course-title">${course.title}</div>
                    <div class="course-meta">${course.units || 'N/A'} units</div>
                </div>
            `;
            }).join('');
        }

        async function openCourse(courseId) {
            try {
                const encodedCourseId = encodeURIComponent(courseId);
                const response = await fetch(`/api/course/${encodedCourseId}`);
                const data = await response.json();
                
                if (!data.success || !data.course) {
                    alert('Error loading course: ' + (data.error || 'Unknown error'));
                    return;
                }
                
                const course = data.course;
                const lectures = course.lectureSections || [];
                const sections = course.sections || [];
                
                // Check if course has standalone sections (no lectures)
                const hasStandaloneSections = lectures.length === 0 && sections.some(s => s.isStandalone);
                
                if (lectures.length === 0 && !hasStandaloneSections) {
                    alert('No lectures or sections available for this course');
                    return;
                }
                
                // Get conflict-free combinations from stored data if available
                conflictFreeCombinations = courseConflictData[courseId] || [];
                
                // If we have selected courses but no conflict data, fetch it
                if (selectedCourses.length > 0 && conflictFreeCombinations.length === 0) {
                    try {
                        const searchResponse = await fetch('/api/search', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                q: courseId, // Search by full courseId (e.g., "CMPSC 16")
                                dept: '',
                                generalSubjects: [], // Empty array when searching by course ID
                                specialSubject: '', // Empty string when searching by course ID
                                selectedCourses: selectedCourses
                            })
                        });
                        const searchData = await searchResponse.json();
                        if (searchData.success && searchData.courses) {
                            const foundCourse = searchData.courses.find(c => c.courseId === courseId);
                            if (foundCourse && foundCourse._conflictFreeCombinations) {
                                conflictFreeCombinations = foundCourse._conflictFreeCombinations;
                                courseConflictData[courseId] = conflictFreeCombinations;
                            }
                        }
                    } catch (error) {
                        console.error('Error fetching conflict data:', error);
                        // Continue without conflict data
                    }
                }
                
                currentCourse = course;
                currentLecture = null;
                selectedLectureIndex = null; // Reset selected lecture
                selectedSectionIndex = null;
                
                showSectionModal();
            } catch (error) {
                alert('Error loading course: ' + error.message);
            }
        }

        function showSectionModal() {
            const modal = document.getElementById('selectionModal');
            const content = document.getElementById('modalContent');
            const lectures = currentCourse.lectureSections || [];
            const sections = currentCourse.sections || [];
            const filterBySchedule = document.getElementById('filterBySchedule').checked;
            const hasSelectedCourses = selectedCourses.length > 0;
            
            // Helper to check if a lecture+section combination is conflict-free
            function isConflictFree(lectureIdx, sectionIdx) {
                // Check conflicts whenever we have conflict data and selected courses
                if (!hasSelectedCourses || conflictFreeCombinations.length === 0) {
                    return true; // No conflicts if no selected courses or no conflict data
                }
                if (lectureIdx === null || lectureIdx === undefined) {
                    return true; // Can't check without a lecture
                }
                // Handle standalone sections (they use lectureIndex but sectionIndex may be set)
                const lecture = lectures[lectureIdx];
                const isStandalone = lecture && lecture.isStandalone;
                if (isStandalone) {
                    // For standalone sections, check if the combination exists (may have sectionIndex set)
                    return conflictFreeCombinations.some(combo => 
                        combo.lectureIndex === lectureIdx && 
                        (combo.isStandalone || combo.sectionIndex === sectionIdx || combo.sectionIndex === null)
                    );
                }
                return conflictFreeCombinations.some(combo => 
                    combo.lectureIndex === lectureIdx && 
                    (sectionIdx === null ? combo.sectionIndex === null : combo.sectionIndex === sectionIdx)
                );
            }
            
            // Helper to check if a lecture is conflict-free (with any section)
            function isLectureConflictFree(lectureIdx) {
                // Check conflicts whenever we have conflict data and selected courses
                if (!hasSelectedCourses || conflictFreeCombinations.length === 0) {
                    return true; // No conflicts if no selected courses or no conflict data
                }
                const lecture = lectures[lectureIdx];
                const isStandalone = lecture && lecture.isStandalone;
                if (isStandalone) {
                    // For standalone sections, check if any combination exists for this lecture
                    return conflictFreeCombinations.some(combo => 
                        combo.lectureIndex === lectureIdx && combo.isStandalone
                    );
                }
                return conflictFreeCombinations.some(combo => combo.lectureIndex === lectureIdx);
            }
            
            let html = `
                <div class="modal-header">
                    <h3>${currentCourse.courseId}: ${currentCourse.title}</h3>
                    <p>Select one lecture${sections.length > 0 ? ' and optionally a section' : ''}</p>
                </div>
            `;
            
            // Auto-select first lecture if none selected (for single lecture courses)
            if (selectedLectureIndex === null && lectures.length === 1) {
                selectedLectureIndex = 0;
            }
            
            // Show all lectures with radio buttons (single selection)
            // Also show standalone sections as selectable items
            if (lectures.length > 0) {
                const hasStandaloneLectures = lectures.some(l => l.isStandalone);
                const sectionTypeLabel = hasStandaloneLectures ? 'Sections' : 'Lectures';
                html += `<div style="margin-bottom: 1rem; color: #374151; font-size: 0.9rem;"><strong>${sectionTypeLabel} (select one):</strong></div>`;
                html += '<div class="section-list" style="margin-bottom: 1.5rem;">';
                lectures.forEach((lecture, idx) => {
                    const lectureTimeStr = lecture.times && lecture.times.length > 0
                        ? lecture.times.map(t => `${t.days} ${formatTime12Hour(t.startTime)}-${formatTime12Hour(t.endTime)}`).join(', ')
                        : 'Time TBA';
                    const isSelected = selectedLectureIndex === idx;
                    const lectureIsConflictFree = isLectureConflictFree(idx);
                    // Show conflict badges whenever there are selected courses and conflict data is available
                    const conflictBadge = hasSelectedCourses && conflictFreeCombinations.length > 0
                        ? (lectureIsConflictFree ? '<span style="color: #059669; font-size: 0.75rem; margin-left: 0.5rem; font-weight: 500;">âœ“ No conflicts</span>' 
                                          : '<span style="color: #dc2626; font-size: 0.75rem; margin-left: 0.5rem; font-weight: 500;">âš  Conflicts</span>')
                        : '';
                    // Only apply opacity when filter is active
                    const opacity = (filterBySchedule && hasSelectedCourses && !lectureIsConflictFree) ? '0.6' : '1';
                    
                    // For standalone sections, show the type (LAB, DIS, etc.)
                    const sectionLabel = lecture.isStandalone && lecture.typeInstruction
                        ? `${lecture.typeInstruction} ${lecture.section || ''}`.trim()
                        : (lecture.section || 'Lecture');
                    
                    html += `
                        <div class="section-item ${isSelected ? 'selected' : ''}" onclick="selectLecture(${idx})" style="opacity: ${opacity}; cursor: pointer;">
                            <div style="display: flex; align-items: start; gap: 0.75rem;">
                                <input type="radio" name="lectureSelection" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); selectLecture(${idx})" style="margin-top: 0.25rem; cursor: pointer;">
                                <div style="flex: 1;">
                                    <div class="lecture-time">${sectionLabel} ${conflictBadge}</div>
                                    <div class="lecture-meta">${lectureTimeStr}</div>
                                    <div class="lecture-meta">${lecture.instructor || 'TBA'}</div>
                                    <div class="lecture-meta">${lecture.enrolled || 0}/${lecture.maxEnroll || 0}</div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            // Show selected lecture/section summary
            if (selectedLectureIndex !== null && selectedLectureIndex < lectures.length) {
                const selectedLecture = lectures[selectedLectureIndex];
                const lectureTimeStr = selectedLecture.times && selectedLecture.times.length > 0
                    ? selectedLecture.times.map(t => `${t.days} ${formatTime12Hour(t.startTime)}-${formatTime12Hour(t.endTime)}`).join(', ')
                    : 'Time TBA';
                const sectionLabel = selectedLecture.isStandalone && selectedLecture.typeInstruction
                    ? `${selectedLecture.typeInstruction} ${selectedLecture.section || ''}`.trim()
                    : (selectedLecture.section || 'Lecture');
                const label = selectedLecture.isStandalone ? 'Selected Section' : 'Selected Lecture';
                html += `
                    <div style="margin-bottom: 1.5rem; padding: 1rem; background: #e8f4f8; border-radius: 4px;">
                        <strong>${label}:</strong><br>
                        ${sectionLabel} - ${lectureTimeStr}
                    </div>
                `;
            }
            
            // Show sections (optional - filtered to only show sections for selected lecture)
            // Collect all sections from selected lecture
            const availableSections = [];
            const sectionToIndexMap = {}; // Map: section enrollCode -> index in sections array
            
            if (selectedLectureIndex !== null && selectedLectureIndex < lectures.length) {
                const lecture = lectures[selectedLectureIndex];
                // For standalone sections, there are no sub-sections - the section itself is the selection
                if (lecture.isStandalone) {
                    // Standalone sections don't have sub-sections, so availableSections stays empty
                    // The lecture itself acts as the selectable item
                } else if (lecture && lecture.sections) {
                    lecture.sections.forEach(section => {
                        // Find original index in sections array for conflict checking
                        const originalIndex = sections.findIndex(s => s.enrollCode === section.enrollCode);
                        sectionToIndexMap[section.enrollCode] = originalIndex >= 0 ? originalIndex : availableSections.length;
                        availableSections.push({
                            ...section,
                            lectureIndex: selectedLectureIndex,
                            originalIndex: originalIndex
                        });
                    });
                }
            }
            
            if (availableSections.length > 0) {
                html += '<div style="margin-bottom: 0.75rem; color: #374151; font-size: 0.9rem;"><strong>Sections (required - select one to add course):</strong></div>';
                html += '<div class="section-list">';
                
                availableSections.forEach((section, localIndex) => {
                    const timeStr = section.times && section.times.length > 0
                        ? section.times.map(t => `${t.days} ${formatTime12Hour(t.startTime)}-${formatTime12Hour(t.endTime)}`).join(', ')
                        : 'Time TBA';
                    const isSelected = section.enrollCode === (selectedSectionIndex !== null && sections[selectedSectionIndex] ? sections[selectedSectionIndex].enrollCode : null) ? 'selected' : '';
                    // Check if section is conflict-free with its associated lecture
                    const sectionIsConflictFree = section.lectureIndex !== undefined
                        ? isConflictFree(section.lectureIndex, section.originalIndex)
                        : true;
                    // Show conflict badges whenever there are selected courses and conflict data is available
                    const conflictBadge = hasSelectedCourses && conflictFreeCombinations.length > 0
                        ? (sectionIsConflictFree ? '<span style="color: #059669; font-size: 0.75rem; margin-left: 0.5rem; font-weight: 500;">âœ“ No conflicts</span>' 
                                          : '<span style="color: #dc2626; font-size: 0.75rem; margin-left: 0.5rem; font-weight: 500;">âš  Conflicts</span>')
                        : '';
                    // Only apply opacity when filter is active
                    const opacity = (filterBySchedule && hasSelectedCourses && !sectionIsConflictFree) ? '0.6' : '1';
                    
                    // Find the original index in sections array for onclick
                    const originalIndex = section.originalIndex >= 0 ? section.originalIndex : localIndex;
                    
                    html += `
                        <div class="section-item ${isSelected}" data-section-index="${originalIndex}" onclick="selectSection(${originalIndex})" style="opacity: ${opacity};">
                            <div class="lecture-time">${section.section || 'Section'} ${conflictBadge}</div>
                            <div class="lecture-meta">${timeStr}</div>
                            <div class="lecture-meta">${section.instructor || 'TBA'}</div>
                            <div class="lecture-meta">${section.enrolled || 0}/${section.maxEnroll || 0}</div>
                        </div>
                    `;
                });
                html += '</div>';
            } else if (selectedLectureIndex !== null && selectedLectureIndex < lectures.length && lectures[selectedLectureIndex].isStandalone) {
                // For standalone sections, no sub-sections are needed - the section itself is the selection
                html += '<div style="margin-bottom: 0.75rem; color: #6b7280; font-size: 0.85rem; font-style: italic;">This is a standalone section - no additional sections to select</div>';
            } else if (sections.length > 0 && selectedLectureIndex === null) {
                html += '<div style="margin-bottom: 0.75rem; color: #6b7280; font-size: 0.85rem; font-style: italic;">Select a lecture to see available sections</div>';
            } else if (sections.length === 0 && lectures.length === 0) {
                html += '<div class="empty-state" style="padding: 1.5rem 1rem;">No sections available</div>';
            } else if (sections.length === 0) {
                html += '<div class="empty-state" style="padding: 1.5rem 1rem;">No sections available</div>';
            } else {
                html += '<div class="empty-state" style="padding: 1.5rem 1rem;">No sections available for selected lecture</div>';
            }
            
            // Check if sections are available and if one is selected
            // For standalone sections, selecting the lecture is enough (no sub-sections needed)
            const selectedLecture = selectedLectureIndex !== null && selectedLectureIndex < lectures.length 
                ? lectures[selectedLectureIndex] 
                : null;
            const isStandaloneSection = selectedLecture && selectedLecture.isStandalone;
            const hasSections = availableSections.length > 0;
            const canAdd = selectedLectureIndex !== null && (isStandaloneSection || (hasSections ? selectedSectionIndex !== null : true));
            const buttonText = isStandaloneSection
                ? 'Add Course'
                : (hasSections 
                    ? (selectedSectionIndex !== null ? 'Add Course' : 'Select a Section First')
                    : 'Add Course');
            
            html += `<button class="add-btn" onclick="addCourse()" ${canAdd ? '' : 'disabled'} style="${!canAdd ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                ${buttonText}
            </button>`;
            
            content.innerHTML = html;
            modal.classList.add('active');
            // Update button state after modal is rendered
            setTimeout(updateAddButtonState, 50);
        }
        
        function selectLecture(index) {
            // Only allow one lecture selection at a time
            const wasSelected = selectedLectureIndex === index;
            if (wasSelected) {
                // Deselect if clicking the same lecture
                selectedLectureIndex = null;
            } else {
                // Select new lecture (automatically deselects previous)
                selectedLectureIndex = index;
            }
            // Clear section selection when lecture changes (always clear when selecting/deselecting)
            selectedSectionIndex = null;
            showSectionModal();
            // Update button state after modal is shown
            setTimeout(updateAddButtonState, 50);
        }
        
        function toggleLecture(index) {
            // Legacy function for backwards compatibility - now just selects
            selectLecture(index);
        }

        function selectSection(index) {
            selectedSectionIndex = index;
            // Only select section items (not lecture items) by using data-section-index attribute
            document.querySelectorAll('.section-item[data-section-index]').forEach((item) => {
                const itemIndex = parseInt(item.getAttribute('data-section-index'));
                if (itemIndex === index) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
            
            // Update the add button state when section is selected
            updateAddButtonState();
        }
        
        function updateAddButtonState() {
            const addBtn = document.querySelector('.add-btn');
            if (!addBtn) return;
            
            const lecture = currentCourse && selectedLectureIndex !== null 
                ? currentCourse.lectureSections[selectedLectureIndex] 
                : null;
            const isStandaloneSection = lecture && lecture.isStandalone;
            const availableSections = lecture && lecture.sections ? lecture.sections : [];
            const hasSections = availableSections.length > 0;
            // For standalone sections, selecting the lecture is enough (no sub-sections needed)
            const canAdd = selectedLectureIndex !== null && (isStandaloneSection || (hasSections ? selectedSectionIndex !== null : true));
            const buttonText = isStandaloneSection
                ? 'Add Course'
                : (hasSections 
                    ? (selectedSectionIndex !== null ? 'Add Course' : 'Select a Section First')
                    : 'Add Course');
            
            addBtn.disabled = !canAdd;
            addBtn.textContent = buttonText;
            addBtn.style.opacity = canAdd ? '1' : '0.5';
            addBtn.style.cursor = canAdd ? 'pointer' : 'not-allowed';
        }

        async function addCourse() {
            // Get selected lecture (only one allowed)
            if (!currentCourse || selectedLectureIndex === null) {
                alert('Error: Please select a lecture or section');
                return;
            }
            
            const lecture = {
                ...currentCourse.lectureSections[selectedLectureIndex],
                index: selectedLectureIndex
            };
            
            // For standalone sections, the lecture itself is the section - no sub-sections needed
            const isStandaloneSection = lecture.isStandalone;
            
            // Check if sections are required and selected (skip for standalone sections)
            const availableSections = lecture.sections || [];
            if (!isStandaloneSection && availableSections.length > 0 && selectedSectionIndex === null) {
                alert('Please select a section before adding the course.');
                return;
            }
            
            const selectedSection = (selectedSectionIndex !== null && currentCourse.sections) 
                ? currentCourse.sections[selectedSectionIndex] 
                : null;
            
            // Find the section that belongs to this lecture (if a section was selected)
            // For standalone sections, use the lecture's enroll code as the section code
            let sectionForThisLecture = null;
            if (isStandaloneSection) {
                // For standalone sections, the lecture itself is the section
                sectionForThisLecture = {
                    enrollCode: lecture.enrollCode,
                    section: lecture.section,
                    times: lecture.times,
                    instructor: lecture.instructor
                };
            } else if (selectedSection) {
                // Check if the selected section belongs to this lecture
                if (lecture.sections && lecture.sections.some(s => s.enrollCode === selectedSection.enrollCode)) {
                    sectionForThisLecture = selectedSection;
                }
            }
            
            try {
                const response = await fetch('/api/section', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lectureCode: lecture.enrollCode,
                        sectionCode: sectionForThisLecture ? sectionForThisLecture.enrollCode : null
                    })
                });
                const data = await response.json();
                
                if (data.success && data.course) {
                    // Check if this lecture is already added (avoid duplicates)
                    const alreadyAdded = selectedCourses.some(c => 
                        c.courseId === data.course.courseId && 
                        c.lecture.enrollCode === data.course.lecture.enrollCode
                    );
                    
                    if (!alreadyAdded) {
                        selectedCourses.push(data.course);
                        
                        // Save to cookie immediately after adding
                        saveSelectedCoursesToCookie();
                        
                        // Auto-optimize after adding course
                        autoOptimize();
                        
                        // Update master schedule and clear preview
                        masterSelectedCourses = JSON.parse(JSON.stringify(selectedCourses));
                        previewScheduleIndex = null;
                        previewSelectedCourses = null;
                        appliedScheduleIndex = null;
                        
                        updateSelectedCoursesList();
                        updateCalendar();
                        closeModal();
                        // Re-search if filter is active
                        if (window.triggerSearchIfFiltered) {
                            window.triggerSearchIfFiltered();
                        }
                    } else {
                        alert('This lecture is already in your schedule.');
                    }
                } else {
                    alert('Error: Failed to add lecture. ' + (data.error || ''));
                }
            } catch (error) {
                console.error('Error adding lecture:', error);
                alert('Error: Failed to add lecture. Please try again.');
            }
        }

        function closeModal() {
            document.getElementById('selectionModal').classList.remove('active');
            currentCourse = null;
            currentLecture = null;
            selectedLectureIndex = null;
            selectedSectionIndex = null;
            conflictFreeCombinations = [];
        }

        function removeCourse(courseId, lectureCode) {
            // Update master schedule and clear preview
            const filtered = selectedCourses.filter(c => 
                !(c.courseId === courseId && c.lecture.enrollCode === lectureCode)
            );
            updateSelectedCourses(filtered);
            masterSelectedCourses = JSON.parse(JSON.stringify(selectedCourses));
            previewScheduleIndex = null;
            previewSelectedCourses = null;
            appliedScheduleIndex = null;
            
            updateSelectedCoursesList();
            updateCalendar();
            // Auto-saved by reactive proxy
            // Re-search if filter is active
            if (window.triggerSearchIfFiltered) {
                window.triggerSearchIfFiltered();
            }
            // Auto-optimize after removing courses
            autoOptimize();
        }

        function updateTotalUnitsDisplay() {
            const totalUnitsElement = document.getElementById('totalUnitsDisplay');
            if (!totalUnitsElement) return;
            
            // Calculate total units from selected courses
            // Group by courseId to avoid double-counting when multiple lectures of same course are selected
            const uniqueCourseIds = new Set();
            let totalUnits = 0;
            
            selectedCourses.forEach(course => {
                if (!course || !course.courseId) return;
                
                const courseId = course.courseId;
                // Only count units once per unique courseId
                if (!uniqueCourseIds.has(courseId)) {
                    // Safely get units - check multiple possible locations
                    const units = parseFloat(course.units) || 
                                 parseFloat(course.unitsFixed) || 
                                 parseFloat(course.unitsVariableHigh) || 
                                 0;
                    totalUnits += units;
                    uniqueCourseIds.add(courseId);
                }
            });
            
            if (selectedCourses.length === 0) {
                totalUnitsElement.textContent = '';
            } else {
                totalUnitsElement.textContent = `(${totalUnits.toFixed(1)} units)`;
            }
        }

        function updateSelectedCoursesList() {
            const container = document.getElementById('selectedCoursesList');
            
            // Update total units display
            updateTotalUnitsDisplay();
            
            if (selectedCourses.length === 0) {
                container.innerHTML = '<div class="empty-state" style="padding: 1.5rem 1rem;">No courses selected</div>';
                return;
            }
            
            // Group courses by courseId to show multiple lectures clearly
            const coursesByCourseId = {};
            selectedCourses.forEach(course => {
                const courseId = course.courseId;
                if (!coursesByCourseId[courseId]) {
                    coursesByCourseId[courseId] = [];
                }
                coursesByCourseId[courseId].push(course);
            });
            
            container.innerHTML = Object.entries(coursesByCourseId).map(([courseId, courses]) => {
                const firstCourse = courses[0];
                const hasMultipleLectures = courses.length > 1;
                
                // Get units for this course
                const units = parseFloat(firstCourse.units) || 
                             parseFloat(firstCourse.unitsFixed) || 
                             parseFloat(firstCourse.unitsVariableHigh) || 
                             0;
                const unitsDisplay = units > 0 ? ` <span style="color: #6b7280; font-weight: 500;">(${units.toFixed(1)} units)</span>` : '';
                
                return `
                    <div class="selected-course">
                        <div class="selected-course-header">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 0.95rem; color: #111827; margin-bottom: 0.375rem;">
                                    ${firstCourse.courseId}${unitsDisplay}${hasMultipleLectures ? ` <span style="color: #6b7280; font-weight: 500;">(${courses.length} lectures)</span>` : ''}
                                </div>
                                <div style="font-size: 0.85rem; color: #6b7280; margin-bottom: 0.75rem;">${firstCourse.title}</div>
                                ${courses.map(course => {
                                    const isStandaloneSection = course.lecture && course.lecture.isStandalone;
                                    const lectureTime = course.lecture.times && course.lecture.times.length > 0
                                        ? course.lecture.times.map(t => 
                                            `${t.days} ${formatTime12Hour(t.startTime)}-${formatTime12Hour(t.endTime)}`
                                          ).join(', ')
                                        : 'Time TBA';
                                    const sectionTime = course.section && course.section.times && course.section.times.length > 0
                                        ? course.section.times.map(t => 
                                            `${t.days} ${formatTime12Hour(t.startTime)}-${formatTime12Hour(t.endTime)}`
                                          ).join(', ')
                                        : 'No section';
                                    
                                    // For standalone sections, show section type (LAB, DIS, etc.) instead of "Lecture"
                                    let lectureLabel = course.lecture.section || 'Lecture';
                                    if (isStandaloneSection && course.lecture.typeInstruction) {
                                        lectureLabel = `${course.lecture.typeInstruction} ${course.lecture.section || ''}`.trim();
                                    }
                                    
                                    return `
                                        <div style="font-size: 0.8rem; color: #374151; margin-top: 0.75rem; padding: 0.75rem; padding-right: 5.5rem; background: #ffffff; border-radius: 6px; border: 1px solid #e5e7eb; position: relative;">
                                            <div style="margin-bottom: 0.375rem;">
                                                <strong style="color: #2563eb;">${isStandaloneSection ? 'Section' : 'Lecture'}:</strong> 
                                                <span style="color: #6b7280;">${lectureLabel} - ${lectureTime}</span>
                                            </div>
                                            ${!isStandaloneSection ? `<div style="color: #6b7280; font-size: 0.75rem;">
                                                Section: ${sectionTime}
                                            </div>` : ''}
                                            <button class="remove-btn" onclick="removeCourse('${course.courseId}', '${course.lecture.enrollCode}')" style="position: absolute; top: 0.75rem; right: 0.75rem;">Remove</button>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Convert 24-hour time to 12-hour format with AM/PM
        function formatTime12Hour(timeStr) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            const period = hours >= 12 ? 'PM' : 'AM';
            const displayHour = hours === 0 ? 12 : (hours > 12 ? hours - 12 : hours);
            const displayMinutes = minutes === 0 ? '' : `:${minutes.toString().padStart(2, '0')}`;
            return `${displayHour}${displayMinutes} ${period}`;
        }

        function initCalendar() {
            const wrapper = document.getElementById('calendarWrapper');
            wrapper.innerHTML = '';
            
            const times = [];
            for (let hour = 8; hour <= 22; hour++) {
                // Add :00 time slot
                const time24_00 = `${hour.toString().padStart(2, '0')}:00`;
                times.push({ time24: time24_00, time12: formatTime12Hour(time24_00), isHour: true });
                
                // Add :30 time slot (except for 10:00 PM which is the last slot)
                if (hour < 22) {
                    const time24_30 = `${hour.toString().padStart(2, '0')}:30`;
                    times.push({ time24: time24_30, time12: formatTime12Hour(time24_30), isHour: false });
                }
            }
            
            const days = [
                { full: 'Monday', abbr: 'Mon', code: 'M' },
                { full: 'Tuesday', abbr: 'Tue', code: 'T' },
                { full: 'Wednesday', abbr: 'Wed', code: 'W' },
                { full: 'Thursday', abbr: 'Thu', code: 'R' },
                { full: 'Friday', abbr: 'Fri', code: 'F' }
            ];
            
            // Create time column
            const timeColumn = document.createElement('div');
            timeColumn.className = 'time-column';
            
            // Time column header (empty spacer)
            const timeHeader = document.createElement('div');
            timeHeader.className = 'time-column-header';
            timeColumn.appendChild(timeHeader);
            
            // Time slots
            times.forEach(({ time12, isHour }) => {
                const timeSlot = document.createElement('div');
                timeSlot.className = 'time-slot' + (isHour ? ' hour-mark' : '');
                timeSlot.textContent = isHour ? time12 : '';
                timeColumn.appendChild(timeSlot);
            });
            wrapper.appendChild(timeColumn);
            
            // Create day columns
            days.forEach(day => {
                const dayColumn = document.createElement('div');
                dayColumn.className = 'day-column';
                
                // Day header
                const header = document.createElement('div');
                header.className = 'day-header';
                header.innerHTML = `<span class="day-label">${day.full}</span><span class="day-abbr">${day.abbr}</span>`;
                dayColumn.appendChild(header);
                
                // Day content container for course blocks
                const dayContent = document.createElement('div');
                dayContent.className = 'day-content';
                dayContent.id = `day-${day.code}`;
                dayColumn.appendChild(dayContent);
                
                wrapper.appendChild(dayColumn);
            });
        }

        function updateCalendar() {
            // Use preview courses if previewing, otherwise use master schedule (fallback to selectedCourses)
            const coursesToDisplay = previewSelectedCourses !== null 
                ? previewSelectedCourses 
                : (masterSelectedCourses.length > 0 ? masterSelectedCourses : selectedCourses);
            updateCalendarWithCourses(coursesToDisplay, previewSelectedCourses !== null);
        }

        function createCourseBlock(label, startTime, endTime, day, color, type, isPreview = false) {
            function timeToMinutes(timeStr) {
                const [hours, minutes] = timeStr.split(':').map(Number);
                return hours * 60 + minutes;
            }
            
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = timeToMinutes(endTime);
            const duration = endMinutes - startMinutes;
            const minutesSince8AM = startMinutes - 480;
            
            // Each 30-minute slot is 30px tall, so 1 minute = 1px
            // Course blocks are positioned in day-content which starts right after header
            const startOffset = minutesSince8AM;
            const height = duration;
            
            // 8 AM to 10 PM = 840 minutes = 840px
            if (minutesSince8AM < 0 || minutesSince8AM > 840 || minutesSince8AM + duration > 840) {
                return null;
            }
            
            // Calculate minimum height needed for all content (padding + text + spacing)
            const minHeightNeeded = 55; // Enough for padding + type + course + time + margins
            const actualHeight = Math.max(height, minHeightNeeded);
            
            // Scale down text for very short blocks
            const isShortBlock = height < 60;
            const scaleFactor = isShortBlock ? Math.max(0.8, height / 75) : 1;
            const padding = isShortBlock ? '0.3rem 0.4rem' : '0.5rem 0.5rem';
            
            const block = document.createElement('div');
            block.className = 'course-block';
            if (isPreview) {
                block.classList.add('preview-block');
            }
            block.style.top = `${startOffset}px`;
            block.style.height = `${actualHeight}px`;
            block.style.background = color;
            block.style.padding = padding;
            
            // Format time display
            const timeDisplay = `${formatTime12Hour(startTime)} - ${formatTime12Hour(endTime)}`;
            
            // Create type label (Lecture/Section)
            const typeDiv = document.createElement('div');
            typeDiv.textContent = type || 'Lecture';
            typeDiv.style.fontSize = `${0.65 * scaleFactor}rem`;
            typeDiv.style.opacity = '1';
            typeDiv.style.lineHeight = isShortBlock ? '1.2' : '1.3';
            typeDiv.style.textAlign = 'center';
            typeDiv.style.width = '100%';
            typeDiv.style.fontWeight = '600';
            typeDiv.style.textTransform = 'uppercase';
            typeDiv.style.letterSpacing = '0.5px';
            if (isShortBlock) {
                typeDiv.style.marginTop = '1px';
            }
            
            // Create course label
            const labelDiv = document.createElement('div');
            labelDiv.textContent = label;
            labelDiv.style.fontWeight = '700';
            labelDiv.style.fontSize = `${0.8 * scaleFactor}rem`;
            labelDiv.style.lineHeight = isShortBlock ? '1.2' : '1.3';
            labelDiv.style.textAlign = 'center';
            labelDiv.style.width = '100%';
            labelDiv.style.marginTop = isShortBlock ? '1px' : '3px';
            labelDiv.style.letterSpacing = '0.2px';
            
            // Create time display
            const timeDiv = document.createElement('div');
            timeDiv.textContent = timeDisplay;
            timeDiv.style.fontSize = `${0.7 * scaleFactor}rem`;
            timeDiv.style.opacity = '1';
            timeDiv.style.lineHeight = isShortBlock ? '1.2' : '1.3';
            timeDiv.style.marginTop = isShortBlock ? '1px' : '2px';
            timeDiv.style.textAlign = 'center';
            timeDiv.style.width = '100%';
            timeDiv.style.fontWeight = '500';
            
            block.appendChild(typeDiv);
            block.appendChild(labelDiv);
            block.appendChild(timeDiv);
            
            block.title = `${type || 'Lecture'}: ${label}\n${timeDisplay}`;
            
            return block;
        }

        // Schedule Optimization Functions
        let optimizedSchedules = [];
        let previewScheduleIndex = null; // Index of schedule being previewed
        let appliedScheduleIndex = null; // Index of actually applied schedule
        let optimizeTimeout = null;
        let masterSelectedCourses = []; // Master schedule (what's actually saved)
        let previewSelectedCourses = null; // Temporary preview courses

        function updateOptimizerStatus(message, type = '') {
            const statusEl = document.getElementById('optimizerStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = `optimizer-status ${type}`;
            }
        }

        async function optimizeSchedule() {
            // Use master schedule for optimization
            const coursesToOptimize = masterSelectedCourses.length > 0 ? masterSelectedCourses : selectedCourses;
            
            if (coursesToOptimize.length === 0) {
                const optimizedSchedulesDiv = document.getElementById('optimizedSchedules');
                if (optimizedSchedulesDiv) {
                    optimizedSchedulesDiv.style.display = 'none';
                }
                updateOptimizerStatus('', '');
                // Clear preview and applied schedule if no courses
                previewScheduleIndex = null;
                previewSelectedCourses = null;
                appliedScheduleIndex = null;
                const previewIndicator = document.getElementById('previewIndicator');
                if (previewIndicator) {
                    previewIndicator.style.display = 'none';
                }
                updateCalendar();
                return;
            }

            const scheduleOptions = document.getElementById('scheduleOptions');
            const optimizedSchedulesDiv = document.getElementById('optimizedSchedules');

            // Remember if a preview was active before optimization
            const wasPreviewing = previewScheduleIndex !== null;
            
            // Clear applied schedule index when re-optimizing (settings changed)
            // The applied schedule is based on old settings, so it's no longer valid
            if (appliedScheduleIndex !== null) {
                appliedScheduleIndex = null;
            }

            updateOptimizerStatus('Calculating optimal schedules...', 'loading');
            scheduleOptions.innerHTML = '<div class="loading-optimization">Finding optimal schedules...</div>';
            optimizedSchedulesDiv.style.display = 'block';

            // Collect preferences
            const spreadPreference = document.querySelector('input[name="spreadPreference"]:checked').value;
            const preferredStartTimeSelect = document.getElementById('preferredStartTime');
            const preferredEndTimeSelect = document.getElementById('preferredEndTime');
            const preferredStartTime = preferredStartTimeSelect.value || null;
            const preferredEndTime = preferredEndTimeSelect.value || null;
            const prioritizeFreeDays = document.getElementById('prioritizeFreeDays').checked;
            const minimizeGaps = document.getElementById('minimizeGaps').checked;
            const maxClassesPerDay = document.getElementById('maxClassesPerDay').value || null;
            const preferredTimeOfDay = document.querySelector('input[name="preferredTimeOfDay"]:checked')?.value || null;

            const preferences = {
                spreadPreference: spreadPreference,
                preferredStartTime: preferredStartTime,
                preferredEndTime: preferredEndTime,
                prioritizeFreeDays: prioritizeFreeDays,
                minimizeGaps: minimizeGaps,
                maxClassesPerDay: maxClassesPerDay ? parseInt(maxClassesPerDay) : null,
                preferredTimeOfDay: preferredTimeOfDay
            };

            // Get course IDs from master schedule
            const courseIds = coursesToOptimize.map(c => c.courseId);

            try {
                const response = await fetch('/api/optimize-schedule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        courseIds: courseIds,
                        preferences: preferences,
                        maxResults: 10
                    })
                });

                const data = await response.json();

                if (data.success) {
                    optimizedSchedules = data.schedules;
                    
                    // Display schedules without automatically applying
                    if (data.schedules.length > 0) {
                        displayOptimizedSchedules(data.schedules);
                        
                        // If a preview was active before optimization, automatically preview the first (best) option
                        if (wasPreviewing) {
                            previewScheduleOption(0);
                        }
                    } else {
                        // Clear selection if no schedules found
                        previewScheduleIndex = null;
                        previewSelectedCourses = null;
                        appliedScheduleIndex = null;
                        const previewIndicator = document.getElementById('previewIndicator');
                        if (previewIndicator) {
                            previewIndicator.style.display = 'none';
                        }
                        updateCalendar();
                        displayOptimizedSchedules([]);
                    }
                } else {
                    scheduleOptions.innerHTML = `<div class="empty-state">Error: ${data.error || 'Failed to optimize schedules'}</div>`;
                    updateOptimizerStatus('Error optimizing schedules', 'error');
                    // Clear preview on error
                    if (wasPreviewing) {
                        previewScheduleIndex = null;
                        previewSelectedCourses = null;
                        const previewIndicator = document.getElementById('previewIndicator');
                        if (previewIndicator) {
                            previewIndicator.style.display = 'none';
                        }
                        updateCalendar();
                    }
                }
            } catch (error) {
                console.error('Optimization error:', error);
                scheduleOptions.innerHTML = '<div class="empty-state">Error optimizing schedules. Please try again.</div>';
                updateOptimizerStatus('Error optimizing schedules', 'error');
                // Clear preview on error
                if (wasPreviewing) {
                    previewScheduleIndex = null;
                    previewSelectedCourses = null;
                    const previewIndicator = document.getElementById('previewIndicator');
                    if (previewIndicator) {
                        previewIndicator.style.display = 'none';
                    }
                    updateCalendar();
                }
            }
        }

        function autoOptimize() {
            // Clear applied schedule when settings change (since it's based on old settings)
            // The masterSelectedCourses already contains the current schedule, so we just need to clear the applied index
            if (appliedScheduleIndex !== null) {
                appliedScheduleIndex = null;
                // Update display immediately to remove "Applied" badge
                if (optimizedSchedules.length > 0) {
                    displayOptimizedSchedules(optimizedSchedules);
                }
            }
            
            // Debounce optimization to avoid too many API calls
            clearTimeout(optimizeTimeout);
            optimizeTimeout = setTimeout(() => {
                optimizeSchedule();
            }, 500); // Wait 500ms after last change
        }

        function displayOptimizedSchedules(schedules) {
            const scheduleOptions = document.getElementById('scheduleOptions');
            
            // Clear selection if selected index is out of bounds
            if (previewScheduleIndex !== null && previewScheduleIndex >= schedules.length) {
                previewScheduleIndex = null;
                previewSelectedCourses = null;
            }
            if (appliedScheduleIndex !== null && appliedScheduleIndex >= schedules.length) {
                appliedScheduleIndex = null;
            }

            if (schedules.length === 0) {
                scheduleOptions.innerHTML = '<div class="empty-state">No valid schedule combinations found. Try adjusting your preferences or selecting different courses.</div>';
                updateOptimizerStatus('No valid schedules found', 'error');
                return;
            }

            scheduleOptions.innerHTML = schedules.map((schedule, index) => {
                const coursesList = schedule.courses.map(course => {
                    let timesStr = '';
                    if (course.lecture && course.lecture.times && course.lecture.times.length > 0) {
                        const lecTimes = course.lecture.times.map(t => 
                            `${t.days} ${formatTime12Hour(t.startTime)}-${formatTime12Hour(t.endTime)}`
                        ).join(', ');
                        timesStr = `Lec: ${lecTimes}`;
                    }
                    if (course.section && course.section.times && course.section.times.length > 0) {
                        const secTimes = course.section.times.map(t => 
                            `${t.days} ${formatTime12Hour(t.startTime)}-${formatTime12Hour(t.endTime)}`
                        ).join(', ');
                        timesStr += timesStr ? ` | Sec: ${secTimes}` : `Sec: ${secTimes}`;
                    }
                    // Get units for this course
                    const units = parseFloat(course.units) || 
                                 parseFloat(course.unitsFixed) || 
                                 parseFloat(course.unitsVariableHigh) || 
                                 0;
                    const unitsDisplay = units > 0 ? ` <span style="color: #6b7280;">(${units.toFixed(1)} units)</span>` : '';
                    return `<div class="schedule-course-item"><strong>${course.courseId}</strong>${unitsDisplay}: ${timesStr || 'TBA'}</div>`;
                }).join('');

                const isPreviewing = index === previewScheduleIndex;
                const isApplied = index === appliedScheduleIndex;

                return `
                    <div class="schedule-option ${isPreviewing ? 'selected' : ''} ${isApplied ? 'applied' : ''}" onclick="previewScheduleOption(${index})">
                        <div class="schedule-header">
                            <strong>Option ${index + 1}${isApplied ? ' <span class="applied-badge">Applied</span>' : isPreviewing ? ' <span style="font-size: 0.75rem; color: #3b82f6; font-weight: normal; margin-left: 0.5rem;">(Previewing)</span>' : ''}</strong>
                            <span class="schedule-score">Score: ${Math.round(schedule.score)}</span>
                        </div>
                        <div class="schedule-courses-list">
                            ${coursesList}
                        </div>
                        ${isPreviewing ? `
                        <div class="schedule-actions" onclick="event.stopPropagation();">
                            <button class="apply-schedule-btn" onclick="applySelectedSchedule();">Apply Schedule</button>
                        </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
            
            // Update status after displaying schedules
            updateOptimizerStatus('', '');
        }

        function previewScheduleOption(index) {
            const schedule = optimizedSchedules[index];
            if (!schedule) {
                return;
            }

            // Ensure master schedule is initialized
            if (masterSelectedCourses.length === 0) {
                masterSelectedCourses = JSON.parse(JSON.stringify(selectedCourses));
            }

            // Build preview courses from schedule
            const courseMap = {};
            schedule.courses.forEach(optCourse => {
                courseMap[optCourse.courseId] = optCourse;
            });

            // Create preview courses - match courses from master schedule
            previewSelectedCourses = masterSelectedCourses.map(course => {
                const optCourse = courseMap[course.courseId];
                if (optCourse) {
                    return {
                        courseId: course.courseId,
                        title: course.title || optCourse.title,
                        units: course.units || optCourse.units || 0,
                        lecture: optCourse.lecture,
                        section: optCourse.section || null
                    };
                }
                return course;
            }).filter(course => {
                // Only include courses that are in the optimized schedule
                return courseMap[course.courseId] !== undefined;
            });

            // Update preview index
            previewScheduleIndex = index;

            // Show preview indicator
            const previewIndicator = document.getElementById('previewIndicator');
            if (previewIndicator) {
                previewIndicator.style.display = 'block';
            }

            // Show preview on calendar
            updateCalendarWithCourses(previewSelectedCourses, true);
            displayOptimizedSchedules(optimizedSchedules);
        }

        function cancelPreview() {
            previewScheduleIndex = null;
            previewSelectedCourses = null;
            
            // Hide preview indicator
            const previewIndicator = document.getElementById('previewIndicator');
            if (previewIndicator) {
                previewIndicator.style.display = 'none';
            }
            
            // Restore master schedule
            updateCalendarWithCourses(masterSelectedCourses, false);
            displayOptimizedSchedules(optimizedSchedules);
        }

        function applySelectedSchedule() {
            if (previewScheduleIndex === null) {
                return;
            }

            const schedule = optimizedSchedules[previewScheduleIndex];
            if (!schedule) {
                return;
            }

            // Apply preview to master schedule
            const newCourses = JSON.parse(JSON.stringify(previewSelectedCourses));
            console.log('ðŸ”„ Applying schedule with', newCourses.length, 'courses');
            
            masterSelectedCourses = newCourses;
            
            // Update selectedCourses - this will auto-save
            updateSelectedCourses(newCourses);
            
            // Double-check: ensure save happened
            console.log('ðŸ’¾ Verifying save - selectedCourses now has', selectedCourses.length, 'courses');
            
            appliedScheduleIndex = previewScheduleIndex;
            previewScheduleIndex = null;
            previewSelectedCourses = null;

            // Hide preview indicator
            const previewIndicator = document.getElementById('previewIndicator');
            if (previewIndicator) {
                previewIndicator.style.display = 'none';
            }

            // Update UI
            updateSelectedCoursesList();
            updateCalendarWithCourses(selectedCourses, false);
            displayOptimizedSchedules(optimizedSchedules);
            
            // Save is already done by updateSelectedCourses, but ensure it happened
            console.log('ðŸ’¾ Schedule applied. Current courses:', selectedCourses.length);

            // Visual feedback
            const scheduleOption = document.querySelectorAll('.schedule-option')[appliedScheduleIndex];
            if (scheduleOption) {
                scheduleOption.classList.add('applying');
                setTimeout(() => scheduleOption.classList.remove('applying'), 600);
            }

            const calendarContainer = document.querySelector('.calendar-container');
            if (calendarContainer) {
                calendarContainer.classList.add('updating');
                setTimeout(() => calendarContainer.classList.remove('updating'), 600);
            }
        }

        function updateCalendarWithCourses(courses, isPreview) {
            // Remove existing blocks with a quick fade-out
            const existingBlocks = document.querySelectorAll('.course-block');
            const fadeOutDuration = 80; // Faster fade-out for smoother transitions
            
            if (existingBlocks.length > 0) {
                existingBlocks.forEach(block => {
                    block.style.transition = `opacity ${fadeOutDuration}ms ease-out`;
                    block.style.opacity = '0';
                });
            }

            // Remove blocks from DOM and add new ones in the same frame for seamless transition
            setTimeout(() => {
                // Remove blocks from DOM
                existingBlocks.forEach(block => {
                    if (block.parentNode) {
                        block.parentNode.removeChild(block);
                    }
                });

                // Add new blocks immediately
                const colors = [
                    '#0066cc', '#008855', '#cc6600', '#9900cc', '#cc0066',
                    '#0099cc', '#66cc00', '#cc9900', '#cc0099', '#0099ff'
                ];

                courses.forEach((course, courseIndex) => {
                    const color = colors[courseIndex % colors.length];
                    const courseLabel = course.courseId;
                    const isStandaloneSection = course.lecture && course.lecture.isStandalone;

                    // Render lecture times (or standalone section times as sections)
                    if (course.lecture && course.lecture.times) {
                        // Determine the type label - use section type for standalone sections
                        let typeLabel = 'Lecture';
                        if (isStandaloneSection) {
                            // For standalone sections, use the section type (LAB, DIS, etc.) or default to 'Section'
                            typeLabel = course.lecture.typeInstruction || 'Section';
                        }
                        
                        course.lecture.times.forEach(timeInfo => {
                            timeInfo.days.split('').forEach(day => {
                                if (['M', 'T', 'W', 'R', 'F'].includes(day)) {
                                    const block = createCourseBlock(
                                        courseLabel,
                                        timeInfo.startTime,
                                        timeInfo.endTime,
                                        day,
                                        color,
                                        typeLabel,
                                        isPreview
                                    );
                                    if (block) {
                                        // Disable slide-in animation for smoother updates
                                        block.style.animation = 'none';
                                        // Start with opacity 0 and fade in quickly
                                        block.style.opacity = '0';
                                        block.style.transition = 'opacity 0.12s ease-in';
                                        document.getElementById(`day-${day}`).appendChild(block);
                                        // Trigger fade-in immediately
                                        requestAnimationFrame(() => {
                                            block.style.opacity = isPreview ? '0.7' : '1';
                                        });
                                    }
                                }
                            });
                        });
                    }

                    // Render section times (only for non-standalone courses)
                    // Standalone sections are already rendered above, so skip them here
                    if (!isStandaloneSection && course.section && course.section.times) {
                        course.section.times.forEach(timeInfo => {
                            timeInfo.days.split('').forEach(day => {
                                if (['M', 'T', 'W', 'R', 'F'].includes(day)) {
                                    const block = createCourseBlock(
                                        courseLabel,
                                        timeInfo.startTime,
                                        timeInfo.endTime,
                                        day,
                                        color,
                                        'Section',
                                        isPreview
                                    );
                                    if (block) {
                                        // Disable slide-in animation for smoother updates
                                        block.style.animation = 'none';
                                        // Start with opacity 0 and fade in quickly
                                        block.style.opacity = '0';
                                        block.style.transition = 'opacity 0.12s ease-in';
                                        document.getElementById(`day-${day}`).appendChild(block);
                                        // Trigger fade-in immediately
                                        requestAnimationFrame(() => {
                                            block.style.opacity = isPreview ? '0.7' : '1';
                                        });
                                    }
                                }
                            });
                        });
                    }
                });
            }, fadeOutDuration);
        }

        function clearAppliedSchedule() {
            appliedScheduleIndex = null;
            previewScheduleIndex = null;
            previewSelectedCourses = null;
            
            // Hide preview indicator
            const previewIndicator = document.getElementById('previewIndicator');
            if (previewIndicator) {
                previewIndicator.style.display = 'none';
            }
            
            // Restore master schedule
            updateSelectedCourses(JSON.parse(JSON.stringify(masterSelectedCourses)));
            
            // Update UI
            updateSelectedCoursesList();
            updateCalendar();
            // Auto-saved by reactive proxy
            displayOptimizedSchedules(optimizedSchedules);
        }


        window.openCourse = openCourse;
        window.selectLecture = selectLecture;
        window.toggleLecture = toggleLecture;
        window.selectSection = selectSection;
        window.addCourse = addCourse;
        window.closeModal = closeModal;
        window.removeCourse = removeCourse;
        window.optimizeSchedule = optimizeSchedule;
        window.previewScheduleOption = previewScheduleOption;
        window.applySelectedSchedule = applySelectedSchedule;
        window.cancelPreview = cancelPreview;
        window.clearAppliedSchedule = clearAppliedSchedule;
        window.toggleSection = toggleSection;

        init();
    </script>
</body>
</html>
